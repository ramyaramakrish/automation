
--------------------------------------------
1. Java Project Structure
--------------------------------------------
Proj-name
|
|-- p1 ( .java / .class files )
|
|-- p2
| |
| |--p21

--------------------------------------------
2. Java File Structure
--------------------------------------------

|------------------------------------------------------------------
|public TypeName.java
|------------------------------------------------------------------
|// package statement ( optional ) - 1
|// import statements ( optional ) - 0..n
|
|// public Type  ( interface | class | enum | annotation | record ) ( Must) - 1
|// default Types( interface | class | enum | annotation | record ) ( optional ) - 0..n
|------------------------------------------------------------------


--------------------------------------------
3. Package Statement
--------------------------------------------

Why we use package statement?
  
  -> to group related types together
  -> to avoid type name conflicts
  -> to control access

syntax:

package package_name;
package level1.level2.level3;

e.g. 
Account.java -> module1 -> project1 -> npci -> com
package com.npci.project1.module1;

--------------------------------------------
4. import Statement
--------------------------------------------

Why we use import statement?
  
  -> to use types of other packages in the current package

project1
|-- p1
|    |-- A.java
|    |-- B.java
|-- p2
|     |-- C.java
|     |-- D.java
|  |--p21
|     |-- G.java
|-- p3
      |-- E.java
      |-- F.java
      |-- C.java

e.g A.java

package p1;
//import p2.C;
//import p2.D;
// or
import p2.*;
import p2.p21.*;
import p3.*;
public class A{
   //code
   B b;
   p3.C c;
   D d;
   G g;
}     


--------------------------------------------
What is class and object?
--------------------------------------------

What is a class?

   -> class is a blue print or template or prototype  which is used
        to create objects.

What is an object?

   -> data|info|attributes|properties     => state
   -> actions|functions|method|operations => behavior
   -> address|location|reference          => identity

   object = state + behavior + identity ( sbi )

--------------------------------------------        
OO Concepts
--------------------------------------------

1. front-end | interface | abstraction
    why we need ?
    -> easy to use/learn by dependent
    -> for loose coupling between dependent and dependee
2. back-end | implementation | encapsulation(hidden)
    why we need ?
    -> to protect the integrity of the data
    -> to hide complexity from dependent

3. Inheritance | reusability | is-a relationship
    -> re-use data | behavior from generalized class to specialized class

4. polymorphism | many-forms
    -> ability to take more than one form

--------------------------------------------    
5. Types ( User Defined Data Types )
--------------------------------------------

---------------------------------------------
a. interface syntax
----------------------------------------------

interface Name [extends interface1, interface2,...] {
    // public static final data members ( constants ) - 0..n
    // public abstract methods ( without body ) - 0..n
}


---------------------------------------------
b. class syntax
----------------------------------------------

how to create an object?
-------------------------
2-step process
step-1: dynamic memory allocation ==> new keyword
step-2: initialization ==> constructor
obj = new Constructor_name( parameters );

________   ________  class Name [extends Superclass_name] [implements interface1, interface2,...] {
[public]   [abstract]    // variable declarations - 0..n ==> state
[      ]   [final]       // constructor declarations - 0..n ==> to initialize state
                         // method declarations - 0..n ==> behavior
                         // inner class declarations - 0..n
                       }


---------------------------------------------
c. enum syntax
----------------------------------------------

why we need enum?
   -> to represent group of named constant values

enum Enum_name {
    CONSTANT1,
    CONSTANT2,
    ...
    CONSTANTn;
}

---------------------------------------------
d. annotation syntax
----------------------------------------------

Why we need annotation?
   -> to provide meta-data info to compiler or runtime environment or frameworks( e,g Junit)
    -> to influence program behavior at compile-time or runtime or framework level
   e.g Junit framework uses @Test annotation to identify test methods

   @Test
   public void testMethod1() {
       // test code
   }

---------------------------------------------    
e. record syntax
----------------------------------------------

Why we need record?
   -> to represent immutable data carrier objects


--------------------------------------------------------------
6. Variables
--------------------------------------------------------------

Why we need variables?
   -> to store data temporarily in the memory during program execution

types of variables by 'data-type'

    1. primitive data-type variables aka values
        -> byte, short, int, long, float, double, char, boolean
    2. reference data-type variables aka objects
        -> interface | class  | enum | annotation | record

    e.g 
        int age=43;
        Student s1 = new Student();

types of variables by 'scope/lifetime'

    1. local variables
        -> declared inside method/constructor/block
        -> scope: within method/constructor/block
        -> lifetime: during method/constructor/block execution
    2. instance variables aka non-static variables
        -> declared inside class but outside method/constructor/block
        -> scope: within object
        -> lifetime: during object lifetime
    3. static variables aka class variables
        -> declared inside class but outside method/constructor/block with static keyword
        -> scope: within class
        -> lifetime: during class loading to unloading


syntax:

 ___________    ________  data-type varName=[value | object's reference];
 [public   ]    [static]
 [protected]    [final]
 [private  ]
 [         ]


 --------------------------------------------------------------
7. constructor
 --------------------------------------------------------------

 in java , object creation is 2-step process
 step-1: dynamic memory allocation ==> new keyword
 step-2: initialization ==> constructor
 

 ___________    ClassName ( [data-type param1, data-type param2,...] ) {
 [public]       // initialization code
 [protected]
 [private  ]
 [         ]
                }

--------------------------------------------
8. methods
--------------------------------------------

Why we need methods?
   -> to implement behavior of an object
   -> to achieve code reusability
   -> to achieve modularity

   return-types
    -> void
    -> primitive data-types ( byte | short | int | long | float | double | char | boolean )
    -> reference data-types ( interface | class | enum | annotation | record )

   syntax:

  _________ __________ return-type methodName ( [data-type param1, data-type param2,...] ) [throws Exception1, Exception2,...] {
  [public]    [static ] // A|R|L and Assignments
  [protected] [final  ] // Conditional statements
  [privte]              // Loops
  [      ]              // method calls
                        // at end => result
                           return [value | object's reference ];    
                        }


--------------------------------------------
Naming Conventions
--------------------------------------------

keywords: lowercase letters ( e.g int, float, class, public, static, void )
packages: all lowercase letters ( e.g com.npci.project1.module1 )
types ( interface | class | enum | annotation | record ): PascalCase ( e.g Student, Account, EmployeeDetails )
methods & variables: camelCase ( e.g getName(), setAge(), studentName, accountBalance )
constants ( public static final variables ): UPPERCASE_WITH_UNDERSCORES ( e.g MAX_VALUE, MIN_AGE )

--------------------------------------------